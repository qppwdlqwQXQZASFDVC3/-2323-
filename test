

local OBFUSCATOR = {}

-- Helper functions
local function generateRandomName(length)
    local chars = {}
    for i = 1, length do
        local r = math.random(1, 3)
        if r == 1 then
            chars[i] = string.char(math.random(97, 122)) -- lowercase
        elseif r == 2 then
            chars[i] = string.char(math.random(65, 90)) -- uppercase
        else
            chars[i] = tostring(math.random(0, 9)) -- number
        end
    end
    return table.concat(chars)
end

local function stringToHex(str)
    return (str:gsub('.', function(c) return string.format('\\x%02X', c:byte()) end))
end

local function stringToDecimal(str)
    local t = {}
    for i = 1, #str do
        t[i] = string.byte(str, i)
    end
    return table.concat(t, ',')
end

local function generateJunkCode(varPrefix, count)
    local junk = {}
    for i = 1, count do
        local varName = varPrefix .. generateRandomName(math.random(8, 15))
        local junkType = math.random(1, 4)
        
        if junkType == 1 then -- random string
            junk[i] = string.format('local %s = "%s"', varName, 
                stringToHex(generateRandomName(math.random(10, 50))))
        elseif junkType == 2 then -- math expression
            junk[i] = string.format('local %s = %d * %d / %d', varName, 
                math.random(1, 100), math.random(1, 100), math.random(1, 10))
        elseif junkType == 3 then -- table
            junk[i] = string.format('local %s = {%s}', varName, 
                table.concat({math.random(1,100), math.random(1,100), math.random(1,100)}, ','))
        else -- function
            junk[i] = string.format('local function %s() return %d end', varName, math.random(1,1000))
        end
    end
    return table.concat(junk, '; ')
end

local function obfuscateString(str, level)
    if level == 1 then -- hex escape
        return string.format('"%s"', stringToHex(str))
    elseif level == 2 then -- decimal escape
        return string.format('string.char(%s)', stringToDecimal(str))
    elseif level == 3 then -- chunk
        return string.format('loadstring(%q)()', str)
    else -- base64 (simulated)
        local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        local b64 = {}
        for i = 1, #str do
            local c = str:sub(i,i)
            b64[i] = b64chars:sub((c:byte() % 64) + 1, (c:byte() % 64) + 1)
        end
        return string.format('(function() local s="%s"; local r=""; for i=1,#s do r=r..string.char(s:byte(i)%64+65) end; return r end)()', 
            table.concat(b64))
    end
end

local function flattenCode(code, varPrefix)
    local parts = {}
    local vars = {}
    local counter = 1
    
    -- Split code into logical chunks
    for line in code:gmatch('([^\n]+)') do
        if not line:match('^%s*%-%-') then -- skip comments
            local varName = varPrefix .. 'part' .. counter
            table.insert(vars, string.format('local %s = %s', varName, obfuscateString(line, math.random(1,3))))
            table.insert(parts, varName)
            counter = counter + 1
        end
    end
    
    -- Combine with junk code
    local junk = generateJunkCode(varPrefix, math.random(5, 10))
    local combined = table.concat(vars, '; ') .. '; ' .. junk .. '; '
    
    -- Create execution chain
    combined = combined .. 'loadstring(table.concat({' .. table.concat(parts, ', ') .. '}, "\\n"))()'
    
    return combined
end

-- Main obfuscation function
function OBFUSCATOR.obfuscate(source, options)
    options = options or {}
    local varPrefix = options.varPrefix or 'OBF_'
    local watermark = options.watermark or 'Obfuscated with Enhanced Lua Obfuscator'
    
    -- Add watermark
    local output = string.format('--[[ %s ]]--\n\n', watermark)
    
    -- Anti-debug measures
    output = output .. string.format([[
        if type(_G) ~= 'table' or type(getfenv) ~= 'function' or type(setmetatable) ~= 'function' then 
            error('Execution environment not supported') 
        end
        local %sENV = setmetatable({}, {__index=_G})
        setfenv(1, %sENV)
    ]], varPrefix, varPrefix)
    
    -- Generate random seed
    local seed = tostring(math.random(1, 1000000))
    output = output .. string.format('local %sSEED = "%s"; ', varPrefix, seed)
    
    -- Add junk code
    output = output .. generateJunkCode(varPrefix, math.random(8, 15)) .. '; '
    
    -- Flatten and obfuscate the source
    local obfuscatedSource = flattenCode(source, varPrefix)
    output = output .. obfuscatedSource
    
    -- Final junk code
    output = output .. '; ' .. generateJunkCode(varPrefix, math.random(3, 7))
    
    return output
end

-- Module interface
return function(source, options)
    if type(source) ~= 'string' then
        source = 'print("Hello World!")'
    end
    
    options = options or {}
    if type(options) == 'string' then
        options = {varPrefix = options}
    end
    
    return OBFUSCATOR.obfuscate(source, options)
end
